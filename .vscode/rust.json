{
    "use itertools": {
        "prefix": ";it",
        "body": [
            "use itertools::*;"
        ],
        "description": "bring all items from itertools"
    },
    "is palindrome": {
        "prefix": ";is_pal",
        "body": [
            "fn is_palindrome(s: &str) -> bool {",
            "\tlet s = s.chars().collect::<Vec<char>>();",
            "\ts == s.iter().rev().copied().collect::<Vec<char>>()",
            "}"
        ],
        "description": "check if a string is a palindrome(回文)"
    },
    "is sorted": {
        "prefix": ";is_sort",
        "body": [
            ".tuple_windows().all(|(a, b)| a <= b)"
        ],
        "description": "check if a slice is sorted"
    },
    "Yes or No": {
        "prefix": ";printyn",
        "body": [
            "println!(\"{}\", if cond { \"Yes\" } else { \"No\" });"
        ],
        "description": "Print Yes or No"
    },
    "rotate matrix": {
        "prefix": ";rotate",
        "body": [
            "fn rotate<T: Copy>(matrix: Vec<Vec<T>>, times: usize) -> Vec<Vec<T>> {",
            "\tlet n = matrix.len();",
            "\tassert!(matrix.iter().all(|row| row.len() == n));",
            "\tif times == 0 {",
            "\t\tmatrix",
            "\t} else {",
            "\t\tlet rotated = (0..n).map(|i| (0..n).map(|j| matrix[n - 1 - j][i]).collect()).collect();",
            "\t\trotate(rotated, times - 1)",
            "\t}",
            "}"
        ],
        "description": "rotate square matrix clockwise"
    },
    "between": {
        "prefix": ";between",
        "body": [
            ".skip_while(|&${1:c}| ${1:c} != $2).skip(1).take_while(|&${1:c}| ${1:c} != $2)"
        ],
        "description": "get the slice between two elements"
    },
    "manhattan distance": {
        "prefix": ";distance_manhattan",
        "body": [
            "// to support before v1.51.0; `unsigned_abs()` is not available",
            "#[allow(clippy::cast_abs_to_unsigned)]",
            "fn manhattan_distance((ax, ay): (usize, usize), (bx, by): (usize, usize)) -> usize {",
            "\t(ax as isize - bx as isize).abs() as usize + (ay as isize - by as isize).abs() as usize",
            "}"
        ],
        "description": "manhattan distance in 2 dimensions"
    },
    "chebyshev distance": {
        "prefix": ";distance_chebyshev",
        "body": [
            "fn chebyshev_distance((ax, ay): (usize, usize), (bx, by): (usize, usize)) -> usize {",
            "\tax.abs_diff(bx).max(ay.abs_diff(by))",
            "}"
        ],
        "description": "chebyshev distance in 2 dimensions"
    },
    "ceiling of division": {
        "prefix": ";ceil_div",
        "body": [
            "($1 + $2 - 1) / $2"
        ],
        "description": "ceiling of a / b is (a + b - 1) / b"
    },
    "binary search (usize)": {
        "prefix": ";bin_search_usize",
        "body": [
            "fn binary_search<F>(mut ng: usize, mut ok: usize, f: F) -> usize",
            "where",
            "\tF: Fn(usize) -> bool,",
            "{",
            "\twhile (ok as isize - ng as isize).abs() > 1 {",
            "\t\tlet mid = (ok + ng) / 2;",
            "\t\tif f(mid) {",
            "\t\t\tok = mid;",
            "\t\t} else {",
            "\t\t\tng = mid;",
            "\t\t}",
            "\t}",
            "\tok",
            "}"
        ],
        "description": "general binary search for usize"
    },
    "binary search (f64)": {
        "prefix": ";bin_search_f64",
        "body": [
            "fn binary_search<F>(mut ng: f64, mut ok: f64, err: f64, f: F) -> f64",
            "where",
            "\tF: Fn(f64) -> bool,",
            "{",
            "\twhile (ok - ng).abs() > err {",
            "\t\tlet mid = (ok + ng) / 2.;",
            "\t\tif f(mid) {",
            "\t\t\tok = mid;",
            "\t\t} else {",
            "\t\t\tng = mid;",
            "\t\t}",
            "\t}",
            "\tok",
            "}"
        ],
        "description": "general binary search for f64"
    },
    "is valid range": {
        "prefix": ";is_valid_range",
        "body": [
            "fn is_valid_range(h: usize, m: usize) -> bool {",
            "\t(0..24).contains(&h) && (0..60).contains(&m)",
            "}"
        ],
        "description": "check if a time is valid"
    },
    "increment time": {
        "prefix": ";increment_time",
        "body": [
            "fn increment_time(mut h: usize, mut m: usize) -> (usize, usize) {",
            "\tm += 1;",
            "\tif m == 60 {",
            "\t\tm = 0;",
            "\t\th += 1;",
            "\t}",
            "\tif h == 24 {",
            "\t\th = 0;",
            "\t}",
            "\t(h, m)",
            "}"
        ],
        "description": "increment time"
    },
    "enumerate divisors": {
        "prefix": ";div",
        "body": [
            "fn enumerate_divisors(n: usize) -> Vec<usize> {",
            "\tlet (mut from_lower, mut from_upper) = (vec![], vec![]);",
            "\tfor i in (1..).take_while(|&i| i * i <= n) {",
            "\t\tif n % i == 0 {",
            "\t\t\tfrom_lower.push(i);",
            "\t\t\tif i != n / i {",
            "\t\t\t\tfrom_upper.push(n / i);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tfrom_upper.reverse();",
            "\t[from_lower, from_upper].concat()",
            "}"
        ],
        "description": "enumerate divisors"
    }
}
