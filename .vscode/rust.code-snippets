{
  "is sorted": {
    "prefix": ";is_sort",
    "body": [
      ".tuple_windows().all(|(a, b)| a <= b)"
    ],
    "description": "check if a slice is sorted"
  },
  "Yes or No": {
    "prefix": ";print_yn",
    "body": [
      "println!(\"{}\", if cond { \"Yes\" } else { \"No\" });"
    ],
    "description": "Print Yes or No"
  },
  "Answer": {
    "prefix": ";print_ans",
    "body": [
      "println!(\"{ans}\");"
    ],
    "description": "Print Answer"
  },
  "between": {
    "prefix": ";between",
    "body": [
      ".skip_while(|&${1:c}| ${1:c} != $2).skip(1).take_while(|&${1:c}| ${1:c} != $2)"
    ],
    "description": "get the slice between two elements"
  },
  "ceiling of division": {
    "prefix": ";ceil_div",
    "body": [
      "($1 + $2 - 1) / $2"
    ],
    "description": "ceiling of a / b is (a + b - 1) / b"
  },
  "binary search (usize)": {
    "prefix": ";bin_search_usize",
    "body": [
      "fn binary_search<F>(mut ng: usize, mut ok: usize, f: F) -> usize",
      "where",
      "\tF: Fn(usize) -> bool,",
      "{",
      "\twhile (ok as isize - ng as isize).abs() > 1 {",
      "\t\tlet mid = (ok + ng) / 2;",
      "\t\tif f(mid) {",
      "\t\t\tok = mid;",
      "\t\t} else {",
      "\t\t\tng = mid;",
      "\t\t}",
      "\t}",
      "\tok",
      "}"
    ],
    "description": "general binary search for usize"
  },
  "binary search (f64)": {
    "prefix": ";bin_search_f64",
    "body": [
      "fn binary_search<F>(mut ng: f64, mut ok: f64, err: f64, f: F) -> f64",
      "where",
      "\tF: Fn(f64) -> bool,",
      "{",
      "\twhile (ok - ng).abs() > err {",
      "\t\tlet mid = (ok + ng) / 2.;",
      "\t\tif f(mid) {",
      "\t\t\tok = mid;",
      "\t\t} else {",
      "\t\t\tng = mid;",
      "\t\t}",
      "\t}",
      "\tok",
      "}"
    ],
    "description": "general binary search for f64"
  },
  ";coord_chebyshev-distance": {
    "prefix": ";coord_chebyshev-distance",
    "body": [
      "fn chebyshev_dst((ax, ay): (usize, usize), (bx, by): (usize, usize)) -> usize {",
      "    ax.abs_diff(bx).max(ay.abs_diff(by))",
      "}"
    ]
  },
  ";coord_manhattan-distance": {
    "prefix": ";coord_manhattan-distance",
    "body": [
      "fn manhattan_dst((ax, ay): (usize, usize), (bx, by): (usize, usize)) -> usize {",
      "    ax.abs_diff(bx) + ay.abs_diff(by)",
      "}"
    ]
  },
  ";iter_split-adjacent": {
    "prefix": ";iter_split-adjacent",
    "body": [
      "use itertools::Itertools;",
      "fn split_adjacent<I, T>(iter: I) -> Vec<Vec<T>>",
      "where",
      "    I: Iterator<Item = T>,",
      "    T: PartialEq + Copy,",
      "{",
      "    iter.group_by(|&s| s).into_iter().map(|(_, group)| group.collect()).collect()",
      "}"
    ]
  },
  ";math_divisors": {
    "prefix": ";math_divisors",
    "body": [
      "fn divisors(n: usize) -> Vec<usize> {",
      "    let (mut lhs, mut rhs) = (vec![], vec![]);",
      "    for i in (1..).take_while(|&i| i * i <= n) {",
      "        if n % i == 0 {",
      "            lhs.push(i);",
      "            rhs.push(n / i);",
      "        }",
      "    }",
      "    let lhs = lhs;",
      "    if rhs.last() == lhs.last() {",
      "        rhs.pop();",
      "    }",
      "    rhs.reverse();",
      "    [lhs, rhs].concat()",
      "}"
    ]
  },
  ";math_gcd": {
    "prefix": ";math_gcd",
    "body": [
      "fn gcd(a: usize, b: usize) -> usize {",
      "    match b {",
      "        0 => a,",
      "        _ => gcd(b, a % b),",
      "    }",
      "}"
    ]
  },
  ";matrix_chunks": {
    "prefix": ";matrix_chunks",
    "body": [
      "fn chunks<T: Copy>(matrix: &Vec<Vec<T>>, side: usize) -> Vec<Vec<Vec<T>>> {",
      "    let (n, m) = (matrix.len(), matrix[0].len());",
      "    assert!(matrix.iter().all(|row| row.len() == m));",
      "    assert!(n % side == 0 && m % side == 0);",
      "    iproduct!((0..n).step_by(side), (0..m).step_by(side))",
      "        .map(|(i, j)| (0..side).map(|k| matrix[i + k][j..j + side].to_vec()).collect())",
      "        .collect()",
      "}"
    ]
  },
  ";matrix_rotate": {
    "prefix": ";matrix_rotate",
    "body": [
      "fn rotate<T: Copy>(matrix: &Vec<Vec<T>>, times: usize) -> Vec<Vec<T>> {",
      "    let (n, m) = (matrix.len(), matrix[0].len());",
      "    assert!(matrix.iter().all(|row| row.len() == m));",
      "    match times {",
      "        0 => matrix.clone(),",
      "        _ => rotate(",
      "            &(0..m).map(|i| (0..n).map(|j| matrix[n - 1 - j][i]).collect()).collect(),",
      "            times - 1,",
      "        ),",
      "    }",
      "}"
    ]
  },
  ";matrix_transpose": {
    "prefix": ";matrix_transpose",
    "body": [
      "fn transpose<T: Copy>(matrix: &Vec<Vec<T>>) -> Vec<Vec<T>> {",
      "    let (n, m) = (matrix.len(), matrix[0].len());",
      "    assert!(matrix.iter().all(|row| row.len() == m));",
      "    (0..m).map(|i| (0..n).map(|j| matrix[j][i]).collect()).collect()",
      "}"
    ]
  },
  ";matrix_windows": {
    "prefix": ";matrix_windows",
    "body": [
      "fn windows<T: Copy>(matrix: &Vec<Vec<T>>, side: usize) -> Vec<Vec<Vec<T>>> {",
      "    let (n, m) = (matrix.len(), matrix[0].len());",
      "    assert!(matrix.iter().all(|row| row.len() == m));",
      "    assert!(n >= side && m >= side);",
      "    iproduct!(0..n - side + 1, 0..m - side + 1)",
      "        .map(|(i, j)| (0..side).map(|k| matrix[i + k][j..j + side].to_vec()).collect())",
      "        .collect()",
      "}"
    ]
  },
  ";time_digits2": {
    "prefix": ";time_digits2",
    "body": [
      "use std::ops::RangeInclusive;",
      "use std::ops::{Bound, RangeBounds};",
      "#[derive(Debug, PartialEq)]",
      "struct Digits2 {",
      "    value: (usize, usize),",
      "    range: (RangeInclusive<usize>, RangeInclusive<usize>),",
      "}",
      "impl Digits2 {",
      "    fn new<T: RangeBounds<usize>>(value: (usize, usize), range: (T, T)) -> Self {",
      "        assert!(range.0.contains(&value.0));",
      "        assert!(range.1.contains(&value.1));",
      "        let decide_range = |r: &T| {",
      "            let start = match r.start_bound() {",
      "                Bound::Included(&s) => s,",
      "                Bound::Excluded(&s) => s + 1,",
      "                Bound::Unbounded => 0,",
      "            };",
      "            let end = match r.end_bound() {",
      "                Bound::Included(&e) => e,",
      "                Bound::Excluded(&e) => e - 1,",
      "                Bound::Unbounded => unreachable!(),",
      "            };",
      "            start..=end",
      "        };",
      "        Self { value, range: (decide_range(&range.0), decide_range(&range.1)) }",
      "    }",
      "    fn wrap(&self) -> Option<Self> {",
      "        Some(Self::new(self.value, self.range.clone()))",
      "    }",
      "    fn inc(&self) -> Option<Self> {",
      "        let (mut a, mut b) = self.value;",
      "        b += 1;",
      "        if b == self.range.1.end() + 1 {",
      "            b = *self.range.1.start();",
      "            a += 1;",
      "        }",
      "        if a == self.range.0.end() + 1 {",
      "            None",
      "        } else {",
      "            Some(Self::new((a, b), self.range.clone()))",
      "        }",
      "    }",
      "    fn value(&self) -> (usize, usize) {",
      "        self.value",
      "    }",
      "}"
    ]
  },
  ";time_digits2_struct": {
    "prefix": ";time_digits2_struct",
    "body": [
      "use std::ops::RangeInclusive;",
      "#[derive(Debug, PartialEq)]",
      "struct Digits2 {",
      "    value: (usize, usize),",
      "    range: (RangeInclusive<usize>, RangeInclusive<usize>),",
      "}"
    ]
  },
  "string_rot": {
    "prefix": "string_rot",
    "body": [
      "fn rot(s: &str, offset: u8) -> String {",
      "    s.bytes()",
      "        .map(|c| match c {",
      "            b'a'..=b'z' => b'a' + (c - b'a' + offset) % 26,",
      "            b'A'..=b'Z' => b'A' + (c - b'A' + offset) % 26,",
      "            _ => c,",
      "        } as char)",
      "        .collect()",
      "}"
    ]
  }
}
