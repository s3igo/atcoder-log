{
  "is sorted": {
    "prefix": ";is_sort",
    "body": [
      ".tuple_windows().all(|(a, b)| a <= b)"
    ],
    "description": "check if a slice is sorted"
  },
  "Yes or No": {
    "prefix": ";printyn",
    "body": [
      "println!(\"{}\", if cond { \"Yes\" } else { \"No\" });"
    ],
    "description": "Print Yes or No"
  },
  "Answer": {
    "prefix": ";printans",
    "body": [
      "println!(\"{ans}\");"
    ],
    "description": "Print Answer"
  },
  "between": {
    "prefix": ";between",
    "body": [
      ".skip_while(|&${1:c}| ${1:c} != $2).skip(1).take_while(|&${1:c}| ${1:c} != $2)"
    ],
    "description": "get the slice between two elements"
  },
  "ceiling of division": {
    "prefix": ";ceil_div",
    "body": [
      "($1 + $2 - 1) / $2"
    ],
    "description": "ceiling of a / b is (a + b - 1) / b"
  },
  "binary search (usize)": {
    "prefix": ";bin_search_usize",
    "body": [
      "fn binary_search<F>(mut ng: usize, mut ok: usize, f: F) -> usize",
      "where",
      "\tF: Fn(usize) -> bool,",
      "{",
      "\twhile (ok as isize - ng as isize).abs() > 1 {",
      "\t\tlet mid = (ok + ng) / 2;",
      "\t\tif f(mid) {",
      "\t\t\tok = mid;",
      "\t\t} else {",
      "\t\t\tng = mid;",
      "\t\t}",
      "\t}",
      "\tok",
      "}"
    ],
    "description": "general binary search for usize"
  },
  "binary search (f64)": {
    "prefix": ";bin_search_f64",
    "body": [
      "fn binary_search<F>(mut ng: f64, mut ok: f64, err: f64, f: F) -> f64",
      "where",
      "\tF: Fn(f64) -> bool,",
      "{",
      "\twhile (ok - ng).abs() > err {",
      "\t\tlet mid = (ok + ng) / 2.;",
      "\t\tif f(mid) {",
      "\t\t\tok = mid;",
      "\t\t} else {",
      "\t\t\tng = mid;",
      "\t\t}",
      "\t}",
      "\tok",
      "}"
    ],
    "description": "general binary search for f64"
  },
  ";coord_chebyshev-distance": {
    "prefix": ";coord_chebyshev-distance",
    "body": [
      "fn chebyshev_dst((ax, ay): (usize, usize), (bx, by): (usize, usize)) -> usize {",
      "    ax.abs_diff(bx).max(ay.abs_diff(by))",
      "}"
    ]
  },
  ";coord_manhattan-distance": {
    "prefix": ";coord_manhattan-distance",
    "body": [
      "fn manhattan_dst((ax, ay): (usize, usize), (bx, by): (usize, usize)) -> usize {",
      "    ax.abs_diff(bx) + ay.abs_diff(by)",
      "}"
    ]
  },
  ";math_divisors": {
    "prefix": ";math_divisors",
    "body": [
      "fn divisors(n: usize) -> Vec<usize> {",
      "    let (mut lhs, mut rhs) = (vec![], vec![]);",
      "    for i in (1..).take_while(|&i| i * i <= n) {",
      "        if n % i == 0 {",
      "            lhs.push(i);",
      "            rhs.push(n / i);",
      "        }",
      "    }",
      "    let lhs = lhs;",
      "    if rhs.last() == lhs.last() {",
      "        rhs.pop();",
      "    }",
      "    rhs.reverse();",
      "    [lhs, rhs].concat()",
      "}"
    ]
  },
  ";math_gcd": {
    "prefix": ";math_gcd",
    "body": [
      "fn gcd(a: usize, b: usize) -> usize {",
      "    match b {",
      "        0 => a,",
      "        _ => gcd(b, a % b),",
      "    }",
      "}"
    ]
  },
  ";matrix_chunks": {
    "prefix": ";matrix_chunks",
    "body": [
      "fn chunks<T: Copy>(matrix: &Vec<Vec<T>>, side: usize) -> Vec<Vec<T>> {",
      "    let n = matrix.len();",
      "    assert!(matrix.iter().all(|row| row.len() == n));",
      "    assert!(n % side == 0);",
      "    iproduct!((0..n).step_by(side), (0..n).step_by(side))",
      "        .map(|(i, j)| iproduct!(0..side, 0..side).map(|(k, l)| matrix[i + k][j + l]).collect())",
      "        .collect()",
      "}"
    ]
  },
  ";matrix_rotate": {
    "prefix": ";matrix_rotate",
    "body": [
      "fn rotate<T: Copy>(matrix: &Vec<Vec<T>>, times: usize) -> Vec<Vec<T>> {",
      "    let (n, m) = (matrix.len(), matrix[0].len());",
      "    assert!(matrix.iter().all(|row| row.len() == m));",
      "    match times {",
      "        0 => matrix.clone(),",
      "        _ => rotate(",
      "            &(0..m).map(|i| (0..n).map(|j| matrix[n - 1 - j][i]).collect()).collect(),",
      "            times - 1,",
      "        ),",
      "    }",
      "}"
    ]
  },
  ";matrix_transpose": {
    "prefix": ";matrix_transpose",
    "body": [
      "fn transpose<T: Copy>(matrix: &Vec<Vec<T>>) -> Vec<Vec<T>> {",
      "    let (n, m) = (matrix.len(), matrix[0].len());",
      "    assert!(matrix.iter().all(|row| row.len() == m));",
      "    (0..m).map(|i| (0..n).map(|j| matrix[j][i]).collect()).collect()",
      "}"
    ]
  },
  ";time_increment": {
    "prefix": ";time_increment",
    "body": [
      "fn increment(mut h: usize, mut m: usize) -> (usize, usize) {",
      "    m += 1;",
      "    if m == 60 {",
      "        m = 0;",
      "        h += 1;",
      "    }",
      "    if h == 24 {",
      "        h = 0;",
      "    }",
      "    (h, m)",
      "}"
    ]
  },
  ";time_is-valid-range": {
    "prefix": ";time_is-valid-range",
    "body": [
      "fn is_valid_range(h: usize, m: usize) -> bool {",
      "    (0..24).contains(&h) && (0..60).contains(&m)",
      "}"
    ]
  }
}
